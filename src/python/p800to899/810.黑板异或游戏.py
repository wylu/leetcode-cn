#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
@File    :   810.黑板异或游戏.py
@Time    :   2021/05/22 21:36:32
@Author  :   wylu
@Version :   1.0
@Contact :   15wylu@gmail.com
@License :   Copyright © 2020, wylu-CHINA-SHENZHEN. All rights reserved.
@Desc    :
"""

#
# @lc app=leetcode.cn id=810 lang=python3
#
# [810] 黑板异或游戏
#
# https://leetcode-cn.com/problems/chalkboard-xor-game/description/
#
# algorithms
# Hard (72.53%)
# Likes:    105
# Dislikes: 0
# Total Accepted:    12.7K
# Total Submissions: 17.5K
# Testcase Example:  '[1,1,2]'
#
# 黑板上写着一个非负整数数组 nums[i] 。Alice 和 Bob 轮流从黑板上擦掉一个数字，Alice
# 先手。如果擦除一个数字后，剩余的所有数字按位异或运算得出的结果等于 0 的话，当前玩家游戏失败。
# (另外，如果只剩一个数字，按位异或运算得到它本身；如果无数字剩余，按位异或运算结果为 0。）
#
# 并且，轮到某个玩家时，如果当前黑板上所有数字按位异或运算结果等于 0，这个玩家获胜。
#
# 假设两个玩家每步都使用最优解，当且仅当 Alice 获胜时返回 true。
#
#
#
# 示例：
#
#
# 输入: nums = [1, 1, 2]
# 输出: false
# 解释:
# Alice 有两个选择: 擦掉数字 1 或 2。
# 如果擦掉 1, 数组变成 [1, 2]。剩余数字按位异或得到 1 XOR 2 = 3。那么 Bob 可以擦掉任意数字，因为 Alice
# 会成为擦掉最后一个数字的人，她总是会输。
# 如果 Alice 擦掉 2，那么数组变成[1, 1]。剩余数字按位异或得到 1 XOR 1 = 0。Alice 仍然会输掉游戏。
#
#
#
#
# 提示：
#
#
# 1 <= N <= 1000
# 0 <= nums[i] <= 2^16
#
#
#
from typing import List
"""
基本分析
这是一道「博弈论」题。

如果没接触过博弈论，其实很难想到，特别是数据范围为 10^3，很具有迷惑性。

如果接触过博弈论，对于这种「判断先手后手的必胜必败」的题目，博弈论方向
是一个优先考虑的方向。

根据题意，如果某位玩家在操作前所有数值异或和为 0，那么该玩家胜利。要我
们判断给定序列时，先手是处于「必胜态」还是「必败态」，如果处于「必胜态」
返回 True，否则返回 False。

对于博弈论的题目，通常有两类的思考方式：

经验分析：见过类似的题目，猜一个性质，然后去证明该性质是否可推广。
状态分析：根据题目给定的规则是判断「胜利」还是「失败」来决定优先分析
  「必胜态」还是「必败态」时具有何种性质，然后证明性质是否可推广。

博弈论
对于本题，给定的是判断「胜利」的规则（在给定序列的情况下，如果所有数值
异或和为 0 可立即判断胜利，其他情况无法立即判断胜负），那么我们应该优先
判断何为「先手必胜态」，如果不好分析，才考虑分析后手的「必败态」。

接下来是分情况讨论：

1. 如果给定的序列异或和为 0，游戏开始时，先手直接获胜：
由此推导出性质一：给定序列 nums 的异或和为 0，先手处于「必胜态」，
返回 True。

2. 如果给定序列异或和不为 0，我们需要分析，先手获胜的话，序列会满足
何种性质：
显然如果要先手获胜，则需要满足「先手去掉一个数，剩余数值异或和必然不为
0；同时后手去掉一个数后，剩余数值异或和必然为 0」。

换句话说，我们需要分析什么情况下「经过一次后手操作」后，序列会以上述
情况 1 的状态，回到先手的局面。

也就是反过来分析想要出现「后手必败态」，序列会有何种性质。

假设后手操作前的异或和为 Sum（Sum != 0），「后手必败态」意味着去掉任意
数字后异或和为 0。同时根据「相同数值异或结果为 0」的特性，我们知道去掉
某个数值，等价于在原有异或和的基础上异或上这个值。

则有：

    Sum' = Sum ^ nums[i] = 0

由于是「后手必败态」，因此 i 取任意一位，都满足上述式子。

则有：

    Sum ^ nums[0] = ... = Sum ^ nums[k] = ... = Sum ^ nums[n - 1] = 0

同时根据「任意数值与 0 异或数值不变」的特性，我们将每一项进行异或：

    (Sum ^ nums[0]) ^ ... ^ (Sum ^ nums[k]) ^ ... ^ (Sum ^ nums[n - 1]) = 0

根据交换律进行变换：

    (Sum ^ Sum ^ ... ^ Sum) ^ (nums[0] ^ ... ^ nums[k] ^ ... ^ nums[n - 1]) = 0


再结合 Sum 为原序列的异或和可得：

    (Sum ^ Sum ^ ... ^ Sum) ^ Sum = 0 , Sum != 0

至此，我们分析出当处于「后手必败态」时，去掉任意一个数值会满足上述式子。

根据「相同数值偶数次异或结果为 0」的特性，可推导出「后手必败态」会导致
交回到先手的序列个数为偶数，由此推导后手操作前序列个数为奇数，后手操作
前一个回合先手为偶数。

由此推导出性质二：只需要保证先手操作前序列个数为偶数时就会出现「后手
必败态」，从而确保先手必胜。

综上，如果序列 nums 本身异或和为 0，天然符合「先手必胜态」的条件，答案
返回 True ；如果序列 nums 异或和不为 0，但序列长度为偶数，那么最终会
出现「后手必败态」，推导出先手必胜，答案返回 True。
"""


# @lc code=start
class Solution:
    def xorGame(self, nums: List[int]) -> bool:
        if len(nums) % 2 == 0:
            return True

        xor = 0
        for num in nums:
            xor ^= num

        return xor == 0


# @lc code=end

if __name__ == '__main__':
    solu = Solution()
    print(solu.xorGame(nums=[1, 1, 2]))
