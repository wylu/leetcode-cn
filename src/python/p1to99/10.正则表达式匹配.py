#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
@File    :   10.正则表达式匹配.py
@Time    :   2020/08/12 23:32:47
@Author  :   wylu
@Version :   1.0
@Contact :   15wylu@gmail.com
@License :   Copyright © 2020, wylu-CHINA-SHENZHEN. All rights reserved.
@Desc    :
"""

#
# @lc app=leetcode.cn id=10 lang=python3
#
# [10] 正则表达式匹配
#
# https://leetcode-cn.com/problems/regular-expression-matching/description/
#
# algorithms
# Hard (30.13%)
# Likes:    1449
# Dislikes: 0
# Total Accepted:    106.7K
# Total Submissions: 354K
# Testcase Example:  '"aa"\n"a"'
#
# 给你一个字符串 s 和一个字符规律 p，请你来实现一个支持 '.' 和 '*' 的正则表达式匹配。
#
# '.' 匹配任意单个字符
# '*' 匹配零个或多个前面的那一个元素
#
#
# 所谓匹配，是要涵盖 整个 字符串 s的，而不是部分字符串。
#
# 说明:
#
#
# s 可能为空，且只包含从 a-z 的小写字母。
# p 可能为空，且只包含从 a-z 的小写字母，以及字符 . 和 *。
#
#
# 示例 1:
#
# 输入:
# s = "aa"
# p = "a"
# 输出: false
# 解释: "a" 无法匹配 "aa" 整个字符串。
#
#
# 示例 2:
#
# 输入:
# s = "aa"
# p = "a*"
# 输出: true
# 解释: 因为 '*' 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 'a'。因此，字符串 "aa" 可被视为 'a' 重复了一次。
#
#
# 示例 3:
#
# 输入:
# s = "ab"
# p = ".*"
# 输出: true
# 解释: ".*" 表示可匹配零个或多个（'*'）任意字符（'.'）。
#
#
# 示例 4:
#
# 输入:
# s = "aab"
# p = "c*a*b"
# 输出: true
# 解释: 因为 '*' 表示零个或多个，这里 'c' 为 0 个, 'a' 被重复一次。因此可以匹配字符串 "aab"。
#
#
# 示例 5:
#
# 输入:
# s = "mississippi"
# p = "mis*is*p*."
# 输出: false
#
#
"""
动态规划

思路与算法:

题目中的匹配是一个「逐步匹配」的过程：我们每次从字符串 p 中取出一个字符或者
「字符 + 星号」的组合，并在 s 中进行匹配。对于 p 中一个字符而言，它只能在 s
中匹配一个字符，匹配的方法具有唯一性；而对于 p 中「字符 + 星号」的组合而言，
它可以在 s 中匹配任意自然数个字符，并不具有唯一性。因此我们可以考虑使用动态
规划，对匹配的方案进行枚举。

我们用 f[i][j] 表示 s 的前 i 个字符与 p 中的前 j 个字符是否能够匹配。在进行
状态转移时，我们考虑 p 的第 j 个字符的匹配情况：

如果 p 的第 j 个字符是一个小写字母，那么我们必须在 s 中匹配一个相同的小写字母，
即：

    f[i][j] = f[i-1][j-1],  s[i] == p[j]
    f[i][j] = false,        s[i] != p[j]

也就是说，如果 s 的第 i 个字符与 p 的第 j 个字符不相同，那么无法进行匹配；
否则我们可以匹配两个字符串的最后一个字符，完整的匹配结果取决于两个字符串前面
的部分。

如果 p 的第 j 个字符是 *，那么就表示我们可以对 p 的第 j−1 个字符匹配任意
自然数次。在匹配 0 次的情况下，我们有

    f[i][j] = f[i][j-2]

也就是我们「浪费」了一个「字符 + 星号」的组合，没有匹配任何 s 中的字符。

在匹配 1,2,3,... 次的情况下，类似地我们有

    f[i][j]=f[i−1][j−2],  if s[i]=p[j−1]
    f[i][j]=f[i−2][j−2],  if s[i−1]=s[i]=p[j−1]
    f[i][j]=f[i−3][j−2],  if s[i−2]=s[i−1]=s[i]=p[j−1]
    ...

如果我们通过这种方法进行转移，那么我们就需要枚举这个组合到底匹配了 s 中的
几个字符，会增导致时间复杂度增加，并且代码编写起来十分麻烦。我们不妨换个角度
考虑这个问题：「字符 + 星号」的组合在匹配的过程中，本质上只会有两种情况：

  - 匹配 s 末尾的一个字符，将该字符扔掉，而该组合还可以继续进行匹配；
  - 不匹配字符，将该组合扔掉，不再进行匹配。

如果按照这个角度进行思考，我们可以写出很精巧的状态转移方程：

    f[i][j] = f[i-1][j] or f[i][j-2],  s[i] == p[i-1]
    f[i][j] = f[i][j-2],               s[i] != p[i-1]

在任意情况下，只要 p[j] 是 .，那么 p[j] 一定成功匹配 s 中的任意一个小写字母。

最终的状态转移方程如下：

                               +-- f[i-1][j-1],  matches(s[i], p[j])
          +-- if(p[j] != '*) = |
          |                    +-- false,        otherwise
f[i][j] = |
          |               +-- f[i-1][j] or f[i][j-2],  matches(s[i], p[j-1])
          +-- otherwise = |
                          +-- f[i][j-2],               otherwise

其中 matches(x,y) 判断两个字符是否匹配的辅助函数。只有当 y 是 .
或者 x 和 y 本身相同时，这两个字符才会匹配。

细节：

动态规划的边界条件为 f[0][0] = true，即两个空字符串是可以匹配的。
最终的答案即为 f[m][n]，其中 m 和 n 分别是字符串 s 和 p 的长度。由于大部分
语言中，字符串的字符下标是从 0 开始的，因此在实现上面的状态转移方程时，需要
注意状态中每一维下标与实际字符下标的对应关系。

在上面的状态转移方程中，如果字符串 p 中包含一个「字符 + 星号」的组合（例如 a*），
那么在进行状态转移时，会先将 a 进行匹配（当 p[j] 为 a 时），再将 a* 作为整体
进行匹配（当 p[j] 为 * 时）。然而，在题目描述中，我们必须将 a* 看成一个整体，
因此将 a 进行匹配是不符合题目要求的。看来我们进行了额外的状态转移，这样会对
最终的答案产生影响吗？

以一个例子详解动态规划转移方程：
S = abbbbc
P = ab*d*c
1. 当 i, j 指向的字符均为字母（或 '.' 可以看成一个特殊的字母）时，
   只需判断对应位置的字符即可，
   若相等，只需判断 i,j 之前的字符串是否匹配即可，转化为子问题 f[i-1][j-1].
   若不等，则当前的 i,j 肯定不能匹配，为 false.

       f[i-1][j-1]   i
            |        |
   S [a  b  b  b  b][c]

   P [a  b  *  d  *][c]
                     |
                     j


2. 如果当前 j 指向的字符为 '*'，则不妨把类似 'a*', 'b*' 等的当成整体看待。
   看下面的例子

            i
            |
   S  a  b [b] b  b  c

   P  a [b  *] d  *  c
            |
            j

   注意到当 'b*' 匹配完 'b' 之后，它仍然可以继续发挥作用。
   因此可以只把 i 前移一位，而不丢弃 'b*', 转化为子问题 f[i-1][j]:

         i
         | <--
   S  a [b] b  b  b  c

   P  a [b  *] d  *  c
            |
            j

   另外，也可以选择让 'b*' 不再进行匹配，把 'b*' 丢弃。
   转化为子问题 f[i][j-2]:

            i
            |
   S  a  b [b] b  b  c

   P [a] b  *  d  *  c
      |
      j <--

3. 冗余的状态转移不会影响答案，
   因为当 j 指向 'b*' 中的 'b' 时, 这个状态对于答案是没有用的,
   原因参见评论区 稳中求胜 的解释, 当 j 指向 '*' 时,
   dp[i][j]只与dp[i][j-2]有关, 跳过了 dp[i][j-1].
"""


# @lc code=start
class Solution:
    def isMatch(self, s: str, p: str) -> bool:
        m, n = len(s), len(p)

        def matches(x: int, y: int) -> bool:
            if x < 0:
                return False
            if p[y] == '.':
                return True
            return s[x] == p[y]

        f = [[False] * (n + 1) for _ in range(m + 1)]
        f[0][0] = True

        for i in range(m + 1):
            for j in range(1, n + 1):
                if p[j - 1] == '*':
                    f[i][j] |= f[i][j - 2]
                    if matches(i - 1, j - 2):
                        f[i][j] |= f[i - 1][j]
                else:
                    if matches(i - 1, j - 1):
                        f[i][j] |= f[i - 1][j - 1]

        return f[m][n]


# @lc code=end
