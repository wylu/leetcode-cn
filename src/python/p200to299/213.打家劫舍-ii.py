#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
@File    :   213.打家劫舍-ii.py
@Time    :   2020/08/21 13:51:33
@Author  :   wylu
@Version :   1.0
@Contact :   15wylu@gmail.com
@License :   Copyright © 2020, wylu-CHINA-SHENZHEN. All rights reserved.
@Desc    :
"""

#
# @lc app=leetcode.cn id=213 lang=python3
#
# [213] 打家劫舍 II
#
# https://leetcode-cn.com/problems/house-robber-ii/description/
#
# algorithms
# Medium (39.31%)
# Likes:    354
# Dislikes: 0
# Total Accepted:    51.8K
# Total Submissions: 131.9K
# Testcase Example:  '[2,3,2]'
#
#
# 你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都围成一圈，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。
#
# 给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额。
#
# 示例 1:
#
# 输入: [2,3,2]
# 输出: 3
# 解释: 你不能先偷窃 1 号房屋（金额 = 2），然后偷窃 3 号房屋（金额 = 2）, 因为他们是相邻的。
#
#
# 示例 2:
#
# 输入: [1,2,3,1]
# 输出: 4
# 解释: 你可以先偷窃 1 号房屋（金额 = 1），然后偷窃 3 号房屋（金额 = 3）。
# 偷窃到的最高金额 = 1 + 3 = 4 。
#
#
from typing import List
"""
此题是 198. 打家劫舍 的拓展版：唯一的区别是此题中的房间是环状排列的
（即首尾相接），而 198. 题中的房间是单排排列的；而这也是此题的难点。

环状排列意味着第一个房子和最后一个房子中只能选择一个偷窃，因此可以把
此环状排列房间问题约化为两个单排排列房间子问题：

  - 在不偷窃第一个房子的情况下（即 nums[1:]），最大金额是 p1；
  - 在不偷窃最后一个房子的情况下（即 nums[:n−1]），最大金额是 p2。

综合偷窃最大金额：为以上两种情况的较大值，即 max(p1,p2) 。

=============================================================

198. 解题思路：
典型的动态规划，以下按照标准流程解题。

状态定义：
  dp[i]: 表示前 i 个房子在满足条件下的能偷窃到的最高金额

转移方程：
  设：有 n 个房子，前 n 间能偷窃到的最高金额是 dp[n]，前 n−1 间能偷窃
  到的最高金额是 dp[n−1] ，此时向这些房子后加一间房，此房间价值为 num ；

  加一间房间后：由于不能抢相邻的房子，意味着抢第 n+1 间就不能抢第 n 间；
  那么前 n+1 间房能偷取到的最高金额 dp[n+1] 一定是以下两种情况的较大值：

  （1）不抢第 n+1 个房间，因此等于前 n 个房子的最高金额，即
       dp[n+1] = dp[n] ；
  （2）抢第 n+1 个房间，此时不能抢第 n 个房间；因此等于前 n−1 个房子的
       最高金额加上当前房间价值，即 dp[n+1] = dp[n-1] + num；

  细心的我们发现：难道在前 n 间的最高金额 dp[n] 情况下，第 n 间一定
  被偷了吗？
  假设没有被偷，那 n+1 间的最大值应该也可能是 dp[n+1] = dp[n] + num 吧？
  其实这种假设的情况可以被省略，这是因为：假设第 n 间没有被偷，那么此时
  dp[n] = dp[n-1]，此时 dp[n+1] = dp[n] + num = dp[n-1] + num，
  即可以将两种情况合并为一种情况考虑；
  假设第 n 间被偷，那么此时 dp[n+1] = dp[n] + num 不可取，因为偷了
  第 n 间就不能偷第 n+1 间。

  最终的转移方程：
  dp[n+1] = max(dp[n], dp[n-1]+num)

初始状态：
  前 0 间房子的最大偷窃价值为 0，即 dp[0] = 0

返回值：
  返回 dp 列表最后一个元素值，即所有房间的最大偷窃价值

简化空间复杂度：
  我们发现 dp[n] 只与 dp[n−1] 和 dp[n−2] 有关系，因此我们可以设两个变量
  cur 和 pre 交替记录，将空间复杂度降到 O(1)。
"""


# @lc code=start
class Solution:
    def rob(self, nums: List[int]) -> int:
        def _rob(nums: List[int]) -> int:
            pre, cur = 0, 0
            for num in nums:
                pre, cur = cur, max(cur, pre + num)
            return cur

        if len(nums) == 1:
            return nums[0]
        return max(_rob(nums[:-1]), _rob(nums[1:]))


# @lc code=end
