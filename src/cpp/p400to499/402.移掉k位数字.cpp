/*
 * @lc app=leetcode.cn id=402 lang=cpp
 *
 * [402] 移掉K位数字
 *
 * https://leetcode-cn.com/problems/remove-k-digits/description/
 *
 * algorithms
 * Medium (30.23%)
 * Likes:    407
 * Dislikes: 0
 * Total Accepted:    40.8K
 * Total Submissions: 128.7K
 * Testcase Example:  '"1432219"\n3'
 *
 * 给定一个以字符串表示的非负整数 num，移除这个数中的 k 位数字，使得剩下的数字最小。
 * 
 * 注意:
 * 
 * 
 * num 的长度小于 10002 且 ≥ k。
 * num 不会包含任何前导零。
 * 
 * 
 * 示例 1 :
 * 
 * 
 * 输入: num = "1432219", k = 3
 * 输出: "1219"
 * 解释: 移除掉三个数字 4, 3, 和 2 形成一个新的最小的数字 1219。
 * 
 * 
 * 示例 2 :
 * 
 * 
 * 输入: num = "10200", k = 1
 * 输出: "200"
 * 解释: 移掉首位的 1 剩下的数字为 200. 注意输出不能有任何前导零。
 * 
 * 
 * 示例 3 :
 * 
 * 
 * 输入: num = "10", k = 2
 * 输出: "0"
 * 解释: 从原数字移除所有的数字，剩余为空就是0。
 * 
 * 
 */

/**
 * @File    :   402.移掉k位数字.cpp
 * @Time    :   2020/11/15 23:01:12
 * @Author  :   wylu
 * @Version :   1.0
 * @Contact :   15wylu@gmail.com
 * @License :   Copyright © 2020, wylu-CHINA-SHENZHEN. All rights reserved.
 * @Desc    :
 * 方法一：贪心 + 单调栈
 * 对于两个相同长度的数字序列，最左边不同的数字决定了这两个数字的大小，例如，
 * 对于 A = 1axxx，B = 1bxxx，如果 a > b 则 A > B。
 * 
 * 基于此，我们可以知道，若要使得剩下的数字最小，需要保证靠前的数字尽可能小。
 * 
 * 让我们从一个简单的例子开始。给定一个数字序列，例如 425，如果要求我们只删除
 * 一个数字，那么从左到右，我们有 4、2 和 5 三个选择。我们将每一个数字和它的
 * 左邻居进行比较。从 2 开始，2 小于它的左邻居 4。假设我们保留数字 4，那么
 * 所有可能的组合都是以数字 4（即 42，45）开头的。相反，如果移掉 4，留下 2，
 * 我们得到的是以 2 开头的组合（即 25），这明显小于任何留下数字 4 的组合。
 * 因此我们应该移掉数字 4。如果不移掉数字 4，则之后无论移掉什么数字，都不会
 * 得到最小数。
 * 
 * 基于上述分析，我们可以得出「删除一个数字」的贪心策略：
 * 
 * 给定一个长度为 n 的数字序列 d[0],d[1],d[2],...,d[n-1]，从左往右找到
 * 第一个位置 i（i>0）使得 d[i] < d[i-1]，并删去 d[i-1]；如果不存在，
 * 说明整个数字序列单调不降，删去最后一个数字即可。
 * 
 * 基于此，我们可以每次对整个数字序列执行一次这个策略；删去一个字符后，剩下
 * 的 n−1 长度的数字序列就形成了新的子问题，可以继续使用同样的策略，直至
 * 删除 k 次。
 * 
 * 然而暴力的实现复杂度最差会达到 O(nk)（考虑整个数字序列是单调不降的），
 * 因此我们需要加速这个过程。
 * 
 * 考虑从左往右增量的构造最后的答案。我们可以用一个栈维护当前的答案序列，栈中
 * 的元素代表截止到当前位置，删除不超过 k 次个数字后，所能得到的最小整数。
 * 根据之前的讨论：在使用 k 个删除次数之前，栈中的序列从栈底到栈顶单调不降。
 * 
 * 因此，对于每个数字，如果该数字小于栈顶元素，我们就不断地弹出栈顶元素，直到
 *   - 栈为空
 *   - 或者新的栈顶元素不大于当前数字
 *   - 或者我们已经删除了 k 位数字
 * 
 * 上述步骤结束后我们还需要针对一些情况做额外的处理：
 *   - 如果我们删除了 m 个数字且 m<k，这种情况下我们需要从序列尾部删除
 *     额外的 k−m 个数字。
 *   - 如果最终的数字序列存在前导零，我们要删去前导零。
 *   - 如果最终数字序列为空，我们应该返回 0。
 * 
 * 最终，从栈底到栈顶的答案序列即为最小数。
 * 
 * 考虑到栈的特点是后进先出，如果通过栈实现，则需要将栈内元素依次弹出然后
 * 进行翻转才能得到最小数。为了避免翻转操作，可以使用双端队列代替栈的实现。
 */

#include <bits/stdc++.h>
using namespace std;

// @lc code=start
class Solution {
public:
    string removeKdigits(string num, int k) {
        vector<char> st;
        for (auto& digit : num) {
            while (k && !st.empty() && st.back() > digit) {
                k--;
                st.pop_back();
            }
            st.push_back(digit);
        }

        while (k--) st.pop_back();

        string ans = "";
        bool leadingZero = true;
        for (auto& digit : st) {
            if (leadingZero && digit == '0') continue;
            leadingZero = false;
            ans += digit;
        }

        return ans == "" ? "0" : ans;
    }
};
// @lc code=end
